# OOP ( Object Oriented Programming )

현실 세계를 프로그래밍으로 옮겨와 현실 세계의 사물들을 객체로 보고, 그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍하는 기법.

## 5가지 설계 원칙

1. SRP ( Single Responsibility Principle, 단일 책임 원칙 )
   클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 합니다.
   결합도를 낮추기 위함입니다.
   만일 여러 목적을 갖고 있다면, 특정 목적의 코드 수정 시 전체 클래스를 테스트해야 하는 상황이 생기게 됩니다.
   책임을 적절히 분리함으로써 코드 가독성과 유지 보수성을 높이는 이점을 얻을 수 있습니다.

2. OCP ( Open-Closed Principle, 개발 폐쇠 원칙 )
   클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.

3. LSP ( Liskov Substitution Principle, 리스코프 치환 원칙 )
   상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 한다.

4. ISP ( Interface Segregation Principle, 인터페이스 분리 원칙 )
   클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 한다.

5. DIP ( Dependency Inversion Principle, 의존 역전 법칙 )
   클라이언트는 추상화에 의존해야 하며, 구체화에 의존해선 안된다.

# 절차지향 프로그래밍 vs 객체지향 프로그래밍 vs 함수형 프로그래밍

## 절차지향 프로그래밍

- 순차적인 처리를 중요시하는 프로그래밍 기법.
- 컴퓨터 처리 구조와 유사해 실행 속도가 빠르다.
- 코드 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

### Pros

- 실행 속도가 빠릅니다.

### Cons

- 유지보수가 어렵습니다.
- 한 부분이 장애가 발생하면 장애가 확산됩니다.
- 융통성 부족으로 생산 효율이 떨어집니다. ( 순서가 바뀌면 결과가 달라질 가능성이 높음 )

## 객체지향 프로그래밍

- 실제 세계 사물을 객체로 모델링하여 개발하는 프로그래밍 기법.
- 다형성, 캡슐화, 상속, 추상화 기법을 이용할 수 있다.
    - 다형성: 하나의 객체가 다른 여러 객체로 재구성되는 것.
    - 캡슐화 : 데이터와 알고리즘을 하나로 묶습니다. 이로 인해 외부에서 내부 형태를 알 수 없습니다.
    - 상속 : 상위 클래스의 모든 요소를 하위 클래스가 이어 받습니다.
    - 추상화 : 공통적인 부분만 파악해서 추출하고 필요하지 않은 것은 제거합니다.

### Pros

- 상속이 가능하기 때문에 코드 재사용성이 높습니다.
- 독립된 객체로 이루어져있기 때문에 생산성과 유지보수성이 높습니다.

### Cons

- 모든 객체의 역할과 기능의 이해가 필요하므로 개발 소요 시간이 높습니다.
- 절치지향 프로그래밍의 처리 속도보다 느립니다.

## [함수형 프로그래밍](https://velog.io/@teo/functional-programming)

- 부수 효과 없는 순수 함수를 이용하여 개발하는 프로그래밍 방식.
- 부수 효과 없는 순 함수란 데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수를 의미합니다.
- 자료처리를 수학적 함수의 연산으로 취급하고 상태와 가변 데이터를 멀리하는 패러다임입니다.

### Pros

- 높은 수준의 [추상화](https://evan-moon.github.io/2019/12/15/about-functional-thinking/)를 제공합니다.
- 함수 단위의 코드 재사용성이 높습니다.
- 불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉽습니다.

### Cons

- 순수함수를 구현하기 위해서는 코드의 가독성이 좋지 않을 수 있습니다.
- 함수형 프로그래밍에선 반복이 for문이 아닌 재귀를 통해 이루어집니다. ( Deep copy )  재귀적 코드 스타일은 무한 루프에 빠질 수 있습니다.
- 순수함수를 사용하는 것은 쉬울 수 있지만, 조합하는 것은 쉽지 않습니다.

### 순수함수

- 동일한 입력에는 항상 같은 값을 반환하는 함수.
- 함수의 실행이 프로그램의 실행에 영향을 미치지 않아야 하는 함수.
- 사이드 이펙트가 없는 것.

### 비상태 & 불변성 ( Stateless & Immutability )

- 함수형 프로그래밍에서의 데이ㅌ터는 변하지 않느 불변성을 유지해야 합니다.

### 선언형 함수 ( Expressions )

- 명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 주목하고,
- 선언형 프로그래밍은 무엇을 **할 것**인가에 주목합니다.

### 1급 객체 ( First-class )

- 변수나 데이터 구조안에 담을 수 있습니다.
- 파라미터로 전달할 수 있습니다.
- 반환값으로 사용할 수 있습니다.
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능합니다.
- 동적으로 프로퍼티 할당이 가능합니다.

### 고차함수 ( Higher-order functions )

- 함수를 인자로 전달 할 수 있어야 합니다.
- 함수의 반환 값으로 또 다른 함수를 사용할 수 있습니다.

---

# Memory Structure

| Low memory | Code | 실행할 프로그램의 코드 |
| --- | --- |--------------|
|            | Data | 전역 변수, 정적 변수 |
|            | Heap | 사용자 동적 할당    |
| High memory | Stack | 지역 변수, 매개 변수 |

## Code

- 텍스트 영역이라고도 부릅니다.
- 사용자가 프로그램 실행 명령을 내리면 OS가 프로세스를 만들며, 메모리에 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리합니다.

## Data

- 프로그램의 Global과 Static 변수가 저장되는 영역
- 프로그램 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

## Heap

- 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것은 동적 할당이라고 부릅니다.
- Java에선 가비지 컬렉터가 자동으로 해제해줍니다.
- 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됩니다.

## Stack

- 함수의 호출과 함께 할당되며 Local과 Parameter 변수가 저장되는 영역입니다.
- 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임이라고 합니다.
- 함수의 호출이 완료되면 소멸합니다.
- 높은 주소에서 낮은 주소로 메모리가 할당됩니다.

---

# Parameter vs Argument

## Parameter

- 함수를 선언할 때 사용된 변수.

## Argument

- 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값.

---

# Call By Value vs Call By Reference

## Call By Value

- 인자로 받은 값을 복사하여 처리하는 방식.
- Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존된다.
- 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어난다.

## Call By Reference

- 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식.
- 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.
- 원래의 값에 영향을 주는 리스크가 존재한다.

---

# Framework vs Library

## Framework

- 전체적인 흐름을 자체적으로 제어한다.
- 사용자가 관리해야하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 **제어의 역전 ( IoC, Inversion of Control )**이 적용됩니다.

## Library

- 사용자가 흐름 제어를 하며 필요한 상황에 가져다가 쓸 수 있다.

실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라집니다.

## 병렬 처리 프레임워크의 종류와 특징

### Hadoop

- HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받습니다.
- 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점이 있습니다.
- 하지만 File I/O를 기반으로 작동하기 때문에 처리 속도가 느립니다.

### Spark

- In-Memory 상에서 데이터를 주고 받고 연산을 수행합니다.
- 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 약 100배 정도 빠릅니다.
- 하지만 메모리상에서 처리하기 때문에 장애가 발생할 경우 데이터가 증발합니다.

---

# Synchronous vs Asynchronous

## Synchronous

- 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식.
- 절차 진행이기에 제어하기 쉽습니다.
- 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어집니다.
- EX ) 콜센터

## Asynchronous

- 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
- 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있습니다.
- 작업이 완료된 결과를 제어하기 어렵습니다.
- EX ) 이메일

---

# Message Queue

- Queue 자료 구조를 이용하여 데이터를 관리하는 시스템.
- 비동기 통신 프로트콜을 제공하여 데이터를 빠르게 주고 받을 수 있게 해줍니다.
- Producer가 Message를  Queue에 넣어두면, Consumer가 Message를 가져와 처리하게 됩니다.
- Kafka, Rabbit MQ, AMPQ, Etc…

---

# Docker와 Kubernetes

- 컨테이너 기반의 가상화 기술.
- 기존에는 하드웨어를 가상화하였기 때문에 Host OS 위에 Guest OS를 설치해야 했습니다. 하지만 이러한 방식은 상당히 무겁고 느려 한계가 많이 있었습니다.
- 이를 극복하고자 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 컨테이너 기술이 등장하게 되었고, 컨테이너를 효율적으로 관리하기 위한 Kubernetes가 등장했습니다.

### Pros

- 쉽고 빠른 실행 환경 구축
- 하드웨어 자원 절감
- Docker Hub와 같은 저장소 제공

### Cons

- 개발 초기의 오버헤드
- Linux 친화적

---

# TDD ( Test-Driven Development )

- 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스.
- 개발자는 우선 요구되는 기능에 대한 테스트 케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후 맞게 리팩토링하는 테스트 주고 개발 방식을 의미합니다.
- 테스트 작성을 위해 해당 기능의 요구사항의 이해가 필요하기 때문에 개발 전 요구사항에 집중할 수 있도록 도와줍니다.
- 하지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점으로 뽑힙니다.

# DDD ( Domain-Driven Design )

- 실세계에서 사건이 발생하는 집합인 Domain을 중심으로 설계하는 방법.
- 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계입니다.
- 도메인은 각각 분리되어 있는데, 이러한 관점에서 MSA ( Micro Service Architecture )를 적용하면 용이한 설계를 할 수 있습니다.
- 같은 객체들이 존재할 수 있는데, 문맥에 따라 객체의 역할이 바뀔 수 있는 것이 DDD입니다.

---

# Monolithic Architecture

시스템의 모든 구성요소가 한 구조에 통합되어 있습니다. 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행됩니다. 따라서 시스템의 한 프로세스에 대한 수요가 급증하면 해당 아키텍처 전체를 확장해야 합니다. 코드 베이스가 증가하게 되면 모놀리식 아키텍처의 기능을 추가하거나 개선하기가 더 복잡해집니다.

## Pros

- 소규모 프로젝트에 합리적입니다.
- 개발, 빌드, 배포, 테스트가 용이합니다.

## Cons

- 일부분의 수정사항이 있더도 전체를 빌드하고 배포해야합니다.
- 많은 양의 코드가 밀집되어 유지보수가 힘들어집니다.
- 일부분의 오류가 전체에 영향을 미칩니다.
- 기능별 적합한 기술, 언어, 프레임워크를 선택하기 까다롭습니다.
- Scale out이 불가능합니다.

# MSA ( Micro Service Architecture )

시스템의 모든 구성요소가 한 구조에 통합되어 있는 Monolithic Architecture의 한계점을 극복하고자 등장하게 되었습니다. MSA는 1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할합니다. 해당 서비스는 API를 통해 데이터를 주고 받으며 1개의 큰 서비스를 구성합니다.

## Pros

- 일부 서비스에 장애가 발생하여도 전체 시스템에 장애가 발생하지 않습니다.
- 각각의 서비스를 서로 다른 언어와 프레임워크로 구성할 수 있습니다.
- 서비스 확정성이 높습니다.
- 독립적인 서비스로 배포가 빠르고 모놀리식에 비해 상대적으로 가볍습니다.
- 각 서비스에 따라 개별 서버를 분할할 수 있고 효율적인 자원 관리가 가능합니다.

## Cons

- 서비스가 분리되어 있기에, 테스팅이나 트랜잭션 처리 등이 어렵습니다.
- 서비스 간에 API로 통신하기 때문에 그에 대한 비용이 발생합니다. ( 통신 비용 + Latency )
- 서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어렵습니다.
- 전체 서비스가 커짐에 따라 복잡도가 기하급수적 증가할 수 있습니다.

# Ref